<p><em>(picture from <a href="https://unsplash.com/@dexezekiel">Dex Ezekiel</a>)</em></p>

<p>Today, I was playing with risky naming conflicting (that I generally avoid) and I get confused by a class method/attribute resolution in <em>python</em>.</p>

<p>Specifically I was playing with classes and code samples like the following:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># arg arg arg
</span><span class="k">class</span> <span class="nc">arg</span><span class="p">():</span>
    <span class="k">def</span> <span class="nf">arg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arg</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">arg</span> <span class="o">=</span> <span class="n">arg</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"arg"</span><span class="p">)</span>

<span class="n">arg</span> <span class="o">=</span> <span class="n">arg</span><span class="p">()</span>
<span class="n">arg</span><span class="p">.</span><span class="n">arg</span><span class="p">()</span>
</code></pre></div></div>

<p>And I was confused by the scope of <code class="language-plaintext highlighter-rouge">self</code>:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">parent</span><span class="p">():</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">f</span><span class="p">()</span> <span class="c1"># Boom
</span>    <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span>
    
<span class="k">class</span> <span class="nc">child</span><span class="p">(</span><span class="n">parent</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">f</span> <span class="o">=</span> <span class="s">"not a method"</span>
        <span class="nb">super</span><span class="p">().</span><span class="n">__init__</span><span class="p">()</span>
        
<span class="n">child</span><span class="p">()</span> <span class="c1"># Boom (see above)
</span></code></pre></div></div>

<p>I intended that <code class="language-plaintext highlighter-rouge">self.f()</code> in parent class would call the <em>parent</em> function but it first resolved to child <em>attribute</em> and produced and error:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Traceback (most recent call last):
  File "module.py", line 17, in &lt;module&gt;
    child()
  File "module.py", line 14, in __init__
    super().__init__("tib")
  File "module.py", line 6, in __init__
    self.f()
TypeError: 'str' object is not callable
</code></pre></div></div>

<p>It’s not that strange when you think about it (to get the most “specialized” or “downward” method/attribute) but how do you restrict to the <em>parent</em> class scope with just no method resolution?</p>

<p>Do you know dear fellow python developers?</p>

<p>I don’t need it, but I’m curious :smiley:</p>

<p>If yes, please comment! :smiley:</p>

